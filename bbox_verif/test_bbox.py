#See LICENSE.iitm for license details
'''

Author   : Santhosh Pavan
Email id : santhosha@mindgrovetech.in
Details  : This file consists cocotb testbench for bbox dut

--------------------------------------------------------------------------------------------------
'''
'''
TODO:
Task Description: Add list of instructions in Testfactory block. So that testbench generates tests for listed instructions. One instruction is implemented as an example. 
		  For multiple instructions, provided as comment (see after TestFactory(TB)). Please the use the same format.
                  Note - Comments are provided for TestFactory.
		  Note - The value of instr (ANDN) is a temp value, it needed to be changed according to spec.

Note - Here testbench assumes below verilog port names are generated by bluespec compiler. Please implement the bluespec design with below port names.

 DUT Ports:
 Name                         I/O  size 
 bbox_out                       O    65/33
 CLK                            I     1 
 RST_N                          I     1 
 instr                          I    32
 rs1                            I    64/32
 rs2                            I    64/32
   (instr, rs1, rs2) -> bbox_out
'''


import string
import random
import cocotb
import logging as _log
from cocotb.decorators import coroutine
from cocotb.triggers import Timer, RisingEdge, FallingEdge
from cocotb.binary import BinaryValue
from cocotb.clock import Clock
from cocotb.regression import TestFactory

from bbox_ref_model import bbox_rm



def btd(s):
    ans = 0
    n = len(s)
    for i in range(n):
        if(s[i]=='1'):
            ans += pow(2,n-1-i)
    return ans


def instr_gen(instr_name):
  
# Zba

    if instr_name == 'add_uw':
        return btd('0000100' + '00000' + '00000' + '000' + '00000' + '0111011')

    if instr_name == 'sh1add':
        return btd('0010000' + '00000' + '00000' + '010' + '00000' + '0110011')

    if instr_name == 'sh1add_uw':
        return btd('0010000' + '00000' + '00000' + '010' + '00000' + '0111011')

    if instr_name == 'sh2add':
        return btd('0010000' + '00000' + '00000' + '100' + '00000' + '0110011')

    if instr_name == 'sh2add_uw':
        return btd('0010000' + '00000' + '00000' + '100' + '00000' + '0111011')

    if instr_name == 'sh3add':
        return btd('0010000' + '00000' + '00000' + '110' + '00000' + '0110011')

    if instr_name == 'sh3add_uw':
        return btd('0010000' + '00000' + '00000' + '110' + '00000' + '0111011')

    if instr_name == 'slli_uw':
        return btd('000010' + '000000' + '00000' + '001' + '00000' + '0011011')

#Zbb
    if instr_name=='andn':
        return btd('0100000' + '00000' + '00000' + '111' + '00000' + '0110011')

    if instr_name=='orn':
        return btd('0100000' + '00000' + '00000' + '110' + '00000' + '0110011')

    if instr_name=='xnor':
        return btd('0100000' + '00000' + '00000' + '100' + '00000' + '0110011')

    if instr_name=='clz':
        return btd('0110000' + '00000' + '00000' + '001' + '00000' + '0010011')

    if instr_name=='clzw':
        return btd('0110000' + '00000' + '00000' + '001' + '00000' + '0011011')

    if instr_name=='ctz':
        return btd('0110000' + '00001' + '00000' + '001' + '00000' + '0010011')

    if instr_name=='ctzw':
        return btd('0110000' + '00001' + '00000' + '001' + '00000' + '0011011')

    if instr_name=='cpop':
        return btd('0110000' + '00010' + '00000' + '001' + '00000' + '0010011')

    if instr_name=='cpopw':
        return btd('0110000' + '00010' + '00000' + '001' + '00000' + '0011011')

    if instr_name=='max':
        return btd('0000101' + '00000' + '00000' + '110' + '00000' + '0110011')

    if instr_name=='maxu':
        return btd('0000101' + '00000' + '00000' + '111' + '00000' + '0110011')

    if instr_name=='min':
        return btd('0000101' + '00000' + '00000' + '100' + '00000' + '0110011')

    if instr_name=='minu':
        return btd('0000101' + '00000' + '00000' + '101' + '00000' + '0110011')

    if instr_name=='sext_b':
        return btd('0110000' + '00100' + '00000' + '001' + '00000' + '0010011')

    if instr_name=='sext_h':
        return btd('0110000' + '00101' + '00000' + '001' + '00000' + '0010011')

    if instr_name=='zext_h':
        if(base == 'RV32'):
            return btd('0000100' + '00000' + '00000' + '100' + '00000' + '0110011')
        else:
            return btd('0000100' + '00000' + '00000' + '100' + '00000' + '0111011')

    if instr_name=='rol':
        return btd('0110000' + '00000' + '00000' + '001' + '00000' + '0110011')

    if instr_name=='rolw':
        return btd('0110000' + '00000' + '00000' + '001' + '00000' + '0111011')

    if instr_name=='ror':
        return btd('0110000' + '00000' + '00000' + '101' + '00000' + '0110011')

    if instr_name == 'rori':
        if(base == 'RV32'):
            num = random.randint(0,31)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (5-len(shamt))*'0' + shamt
            return btd('0110000' + shamt + '00000' + '101' + '00000' + '0010011')
        else:
            num = random.randint(0,63)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (6-len(shamt))*'0' + shamt
            return btd('011000' + shamt + '00000' + '101' + '00000' + '0010011')

    if instr_name == 'roriw':
        num = random.randint(0,31)
        shamt = bin(num)
        shamt = shamt[2:]
        shamt = (5-len(shamt))*'0' + shamt
        return btd('0110000' + shamt + '00000' + '101' + '00000' + '0011011')
    
    if instr_name=='rorw':
        return btd('0110000' + '00000' + '00000' + '101' + '00000' + '0111011')

    if instr_name=='orc_b':
        return btd('001010000111' + '00000' + '101' + '00000' + '0010011')

    if instr_name=='rev8':
        if(base == 'RV32'):
            return btd('011010011000' + '00000' + '101' + '00000' + '0010011')
        else:
            return btd('011010111000' + '00000' + '101' + '00000' + '0010011')

#Zbc
    if instr_name=='clmul':
        return btd('0000101' + '00000' + '00000' + '001' + '00000' + '0110011')
    
    if instr_name=='clmulh':
        return btd('0000101' + '00000' + '00000' + '011' + '00000' + '0110011')
    
    if instr_name=='clmulr':
        return btd('0000101' + '00000' + '00000' + '010' + '00000' + '0110011')

# Zbs 
    if instr_name=='bclr':
        return btd('0100100' + '00000' + '00000' + '001' + '00000' + '0110011')

    if instr_name=='bclri':
        if(base == 'RV32'):
            num = random.randint(0,31)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (5-len(shamt))*'0' + shamt
            return btd('0100100' + shamt + '00000' + '001' + '00000' + '0010011')
        else:
            num = random.randint(0,63)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (6-len(shamt))*'0' + shamt
            return btd('010010' + shamt + '00000' + '001' + '00000' + '0010011')

    if instr_name=='bext':
        return btd('0100100' + '00000' + '00000' + '101' + '00000' + '0110011')

    if instr_name=='bexti':
        if(base == 'RV32'):
            num = random.randint(0,31)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (5-len(shamt))*'0' + shamt
            return btd('0100100' + shamt + '00000' + '101' + '00000' + '0010011')
        else:
            num = random.randint(0,63)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (6-len(shamt))*'0' + shamt
            return btd('010010' + shamt + '00000' + '101' + '00000' + '0010011')

    if instr_name=='binv':
        return btd('0110100' + '00000' + '00000' + '001' + '00000' + '0110011')

    if instr_name=='binvi':
        if(base == 'RV32'):
            num = random.randint(0,31)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (5-len(shamt))*'0' + shamt
            return btd('0110100' + shamt + '00000' + '001' + '00000' + '0010011')
        else:
            num = random.randint(0,63)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (6-len(shamt))*'0' + shamt
            return btd('011010' + shamt + '00000' + '001' + '00000' + '0010011')

    if instr_name=='bset':
        return btd('0010100' + '00000' + '00000' + '001' + '00000' + '0110011')

    if instr_name=='bseti':
        if(base == 'RV32'):
            num = random.randint(0,31)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (5-len(shamt))*'0' + shamt
            return btd('0010100' + shamt + '00000' + '001' + '00000' + '0010011')
        else:
            num = random.randint(0,63)
            shamt = bin(num)
            shamt = shamt[2:]
            shamt = (6-len(shamt))*'0' + shamt
            return btd('001010' + shamt + '00000' + '001' + '00000' + '0010011')
    

#generates clock and reset
async def initial_setup(dut):
	cocotb.start_soon(Clock(dut.CLK, 1, units='ns').start())
        
	dut.RST_N.value = 0
	await RisingEdge(dut.CLK)
	dut.RST_N.value = 1


#drives input data to dut
async def input_driver(dut, instr, rs1, rs2, single_opd):
    await RisingEdge(dut.CLK)
    dut.instr.value = instr
    dut.rs1.value = rs1
    dut._log.info("---------------- DUT Input Info -----------------------")
    if single_opd == 1:
        await RisingEdge(dut.CLK)
        dut._log.info("instr = %s  rs1 = %s ",hex(dut.instr.value), hex(dut.rs1.value))

    else :
        dut.rs2.value = rs2
        await RisingEdge(dut.CLK)
        dut._log.info("instr = %s  rs1 = %s rs2 = %s",hex(dut.instr.value), hex(dut.rs1.value), hex(dut.rs2.value))
    dut._log.info("-------------------------------------------------------")

#monitors dut output
async def output_monitor(dut):
    while True:
        await RisingEdge(dut.CLK)
        if(dut.bbox_out.value[0]): break

    dut_result = dut.bbox_out.value
    return dut_result

#compares output of dut and rm
async def scoreboard(dut, dut_result, rm_result):
    dut._log.info("------------ Compare DUT o/p & Ref Model o/p ----------")
    dut._log.info("Expected output  = %s", rm_result)
    dut._log.info("DUT output       = %s", dut_result)
    assert rm_result == str(dut_result),"Failed"
    dut._log.info("-------------------------------------------------------")

#Testbench
async def TB(dut, XLEN, instr, instr_name, single_opd, num_of_tests, custom_testing = False):
    await initial_setup(dut)
    dut._log.info("*******************************************************")
    dut._log.info("------------- Test %r of RV%d starts --------------" %(instr_name,XLEN))
    dut._log.info("*******************************************************")

    custom_testing = False          # Change the boolean value to switch between Random and Custom Testing

    if(not custom_testing):
        # Testing with Random rs1 and rs2
        for i in range (num_of_tests):
            rs1 = random.randint(0,(2**XLEN)-1) 
            rs2 = random.randint(0,(2**XLEN)-1)
            rm_result = bbox_rm(instr, instr_name, rs1, rs2, XLEN)
        
            await input_driver(dut, instr, rs1, rs2, single_opd)
            dut_result = await output_monitor(dut)
        
            await scoreboard(dut, dut_result, rm_result)	

    else:
        # Custom Testing with extreme inputs
        custom_num = 4
        rs1_perm = [0, 0, (2**XLEN)-1, (2**XLEN)-1]
        rs2_perm = [0, (2**XLEN)-1, 0, (2**XLEN)-1]

        for i in range (custom_num):
            rs1 = rs1_perm[i] 
            rs2 = rs2_perm[i]
            rm_result = bbox_rm(instr, instr_name, rs1, rs2, XLEN)
        
            await input_driver(dut, instr, rs1, rs2, single_opd)
            dut_result = await output_monitor(dut)
        
            await scoreboard(dut, dut_result, rm_result)
        # Custom Testing END
            
    dut._log.info("*******************************************************")
    dut._log.info("------------- Test %r of RV%d ends ----------------" %(instr_name,XLEN))
    dut._log.info("*******************************************************")


# generates sets of tests based on the different permutations of the possible arguments to the test function
tf = TestFactory(TB)

base = 'RV64'
#To run tests for RV32, change base = 'RV32'

#generates tests for instructions of RV32
if base == 'RV32':
    tf.add_option('XLEN', [32])
    tf.add_option(('instr','instr_name','single_opd'), \
        [  
            #Zba
            (instr_gen('sh1add'),'sh1add',0),
            (instr_gen('sh2add'),'sh2add',0),
            (instr_gen('sh3add'),'sh3add',0),

            #Zbb
            (instr_gen('andn'), 'andn', 0), 
            (instr_gen('orn'), 'orn', 0), 
            (instr_gen('xnor'), 'xnor', 0), 
            (instr_gen('clz'), 'clz', 1),
            (instr_gen('ctz'), 'ctz', 1), 
            (instr_gen('cpop'), 'cpop', 1), 
            (instr_gen('max'), 'max', 0), 
            (instr_gen('maxu'), 'maxu', 0), 
            (instr_gen('min'), 'min', 0), 
            (instr_gen('minu'), 'minu', 0), 
            (instr_gen('sext_b'), 'sext_b', 1), 
            (instr_gen('sext_h'), 'sext_h', 1), 
            (instr_gen('zext_h'), 'zext_h', 1), 
            (instr_gen('rol'), 'rol', 0), 
            (instr_gen('ror'), 'ror', 0), 
            (instr_gen('rori'), 'rori', 1),
            (instr_gen('orc_b'), 'orc_b', 1),
            (instr_gen('rev8'), 'rev8', 1),


            #Zbc
            (instr_gen('clmul'), 'clmul', 0),
            (instr_gen('clmulh'), 'clmulh', 0),
            (instr_gen('clmulr'), 'clmulr', 0),

            #Zbs
            (instr_gen('bclr'), 'bclr', 0), 
            (instr_gen('bclri'), 'bclri', 1), 
            (instr_gen('bext'), 'bext', 0), 
            (instr_gen('bexti'), 'bexti', 1), 
            (instr_gen('binv'), 'binv', 0), 
            (instr_gen('binvi'), 'binvi', 1), 
            (instr_gen('bset'), 'bset', 0), 
            (instr_gen('bseti'), 'bseti', 1),

        ])


#generates tests for instructions of RV64
elif base == 'RV64':
    tf.add_option('XLEN', [64])

    tf.add_option(('instr','instr_name','single_opd'), \
        [  
            #Zba
            (instr_gen('add_uw'),'add_uw',0), 
            (instr_gen('sh1add'),'sh1add',0), 
            (instr_gen('sh1add_uw'),'sh1add_uw',0), 
            (instr_gen('sh2add'),'sh2add',0),
            (instr_gen('sh2add_uw'),'sh2add_uw',0), 
            (instr_gen('sh3add'),'sh3add',0), 
            (instr_gen('sh3add_uw'),'sh3add_uw',0), 
            (instr_gen('slli_uw'), 'slli_uw', 1), 


            #Zbb
            (instr_gen('andn'), 'andn', 0), 
            (instr_gen('orn'), 'orn', 0), 
            (instr_gen('xnor'), 'xnor', 0), 
            (instr_gen('clz'), 'clz', 1), 
            (instr_gen('clzw'), 'clzw', 1), 
            (instr_gen('ctz'), 'ctz', 1), 
            (instr_gen('ctzw'), 'ctzw', 1), 
            (instr_gen('cpop'), 'cpop', 1), 
            (instr_gen('cpopw'), 'cpopw', 1), 
            (instr_gen('max'), 'max', 0), 
            (instr_gen('maxu'), 'maxu', 0), 
            (instr_gen('min'), 'min', 0), 
            (instr_gen('minu'), 'minu', 0), 
            (instr_gen('sext_b'), 'sext_b', 1), 
            (instr_gen('sext_h'), 'sext_h', 1), 
            (instr_gen('zext_h'), 'zext_h', 1), 
            (instr_gen('rol'), 'rol', 0), 
            (instr_gen('rolw'), 'rolw', 0), 
            (instr_gen('ror'), 'ror', 0), 
            (instr_gen('rori'), 'rori', 1),
            (instr_gen('roriw'), 'roriw', 1),
            (instr_gen('rorw'), 'rorw', 0),
            (instr_gen('orc_b'), 'orc_b', 1),
            (instr_gen('rev8'), 'rev8', 1),


            #Zbc
            (instr_gen('clmul'), 'clmul', 0),
            (instr_gen('clmulh'), 'clmulh', 0),
            (instr_gen('clmulr'), 'clmulr', 0),

            #Zbs
            (instr_gen('bclr'), 'bclr', 0), 
            (instr_gen('bclri'), 'bclri', 1), 
            (instr_gen('bext'), 'bext', 0), 
            (instr_gen('bexti'), 'bexti', 1), 
            (instr_gen('binv'), 'binv', 0), 
            (instr_gen('binvi'), 'binvi', 1), 
            (instr_gen('bset'), 'bset', 0), 
            (instr_gen('bseti'), 'bseti', 1),


        ])

#for each instruction below line generates 10 test vectors, can change to different no.
tf.add_option('num_of_tests',[10])
tf.generate_tests()

